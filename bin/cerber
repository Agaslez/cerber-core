#!/usr/bin/env node

/**
 * Cerber Core - Unified CLI
 * 
 * Main entry point for all Cerber commands
 * 
 * @author Stefan Pitek
 * @license MIT
 */

import chalk from 'chalk';
import { program } from 'commander';

program
  .name('cerber')
  .description('Cerber Core - Code quality & health monitoring')
  .version('1.1.0');

program
  .command('init')
  .description('Initialize Cerber in your project')
  .option('--mode <mode>', 'Override mode: solo | dev | team')
  .option('--force', 'Overwrite existing files')
  .option('--dry-run', 'Show what would be generated without creating files')
  .option('--print-template', 'Print CERBER.md template contract to stdout')
  .option('--no-husky', 'Skip Husky hook generation')
  .option('--no-workflow', 'Skip GitHub Actions workflow generation')
  .option('--no-health', 'Skip health check template generation')
  .option('--write-contract', 'Update CERBER.md contract with CLI options')
  .action(async (options) => {
    const { initCommand } = await import('../dist/cli/init.js');
    await initCommand(options);
  });

program
  .command('guardian')
  .description('Run Guardian pre-commit validation')
  .option('-s, --schema <file>', 'Schema file path')
  .option('-v, --verbose', 'Verbose output')
  .option('--fail-on-warning', 'Exit with error on warnings')
  .action(async (options) => {
    const { Guardian } = await import('../dist/guardian/index.js');
    const schema = options.schema ? await import(options.schema) : null;
    
    const guardian = new Guardian(schema?.default || {});
    const result = await guardian.validate();
    
    if (!result.success) {
      console.error(chalk.red('❌ Guardian validation failed'));
      process.exit(1);
    }
    
    console.log(chalk.green('✅ Guardian validation passed'));
  });

program
  .command('health')
  .description('Run Cerber health checks')
  .option('-c, --checks <file>', 'Health checks file path')
  .option('-u, --url <url>', 'Fetch health from URL')
  .option('-p, --parallel', 'Run checks in parallel')
  .action(async (options) => {
    const { Cerber } = await import('../dist/cerber/index.js');
    
    if (options.url) {
      const response = await fetch(options.url);
      const result = await response.json();
      console.log(JSON.stringify(result, null, 2));
      process.exit(result.status === 'healthy' ? 0 : 1);
    }
    
    const checksModule = options.checks ? await import(options.checks) : null;
    const checks = checksModule ? Object.values(checksModule).filter(v => typeof v === 'function') : [];
    
    const cerber = new Cerber(checks);
    const result = await cerber.runChecks({ parallel: options.parallel });
    
    process.exit(result.status === 'healthy' ? 0 : 1);
  });

program
  .command('morning')
  .description('Run morning dashboard (SOLO)')
  .action(async () => {
    const fs = await import('fs');
    const path = await import('path');
    const scriptPath = path.default.join(process.cwd(), 'solo/scripts/cerber-daily-check.js');
    
    if (!fs.default.existsSync(scriptPath)) {
      console.error(chalk.red('❌ This command requires SOLO mode'));
      console.error(chalk.yellow('Run: npx cerber init --mode solo'));
      console.error(chalk.gray('\nSOLO mode includes daily automation scripts for single developers.'));
      process.exit(1);
    }
    
    const { execSync } = await import('child_process');
    execSync('node solo/scripts/cerber-daily-check.js', { stdio: 'inherit' });
  });

program
  .command('repair')
  .description('Auto-repair common issues (SOLO)')
  .option('--dry-run', 'Show what would be fixed without making changes')
  .option('--approve', 'Require approval for each fix')
  .action(async (options) => {
    const fs = await import('fs');
    const path = await import('path');
    const scriptPath = path.default.join(process.cwd(), 'solo/scripts/cerber-auto-repair.js');
    
    if (!fs.default.existsSync(scriptPath)) {
      console.error(chalk.red('❌ This command requires SOLO mode'));
      console.error(chalk.yellow('Run: npx cerber init --mode solo'));
      console.error(chalk.gray('\nSOLO mode includes auto-repair scripts for maintenance.'));
      process.exit(1);
    }
    
    const { execSync } = await import('child_process');
    const args = [
      options.dryRun && '--dry-run',
      options.approve && '--approve'
    ].filter(Boolean).join(' ');
    
    execSync(`node solo/scripts/cerber-auto-repair.js ${args}`, { stdio: 'inherit' });
  });

program
  .command('focus <module>')
  .description('Generate focus context for module (TEAM)')
  .action(async (module) => {
    const fs = await import('fs');
    const path = await import('path');
    const scriptPath = path.default.join(process.cwd(), 'team/scripts/cerber-focus.sh');
    
    if (!fs.default.existsSync(scriptPath)) {
      console.error(chalk.red('❌ This command requires TEAM mode'));
      console.error(chalk.yellow('Run: npx cerber init --mode team'));
      console.error(chalk.gray('\nTEAM mode includes collaboration tools and CODEOWNERS.'));
      process.exit(1);
    }
    
    const { execSync } = await import('child_process');
    execSync(`bash team/scripts/cerber-focus.sh ${module}`, { stdio: 'inherit' });
  });

program
  .command('dashboard')
  .description('Show system dashboard (SOLO)')
  .action(async () => {
    const fs = await import('fs');
    const path = await import('path');
    const scriptPath = path.default.join(process.cwd(), 'solo/scripts/cerber-dashboard.js');
    
    if (!fs.default.existsSync(scriptPath)) {
      console.error(chalk.red('❌ This command requires SOLO mode'));
      console.error(chalk.yellow('Run: npx cerber init --mode solo'));
      console.error(chalk.gray('\nSOLO mode includes system monitoring dashboards.'));
      process.exit(1);
    }
    
    const { execSync } = await import('child_process');
    execSync('node solo/scripts/cerber-dashboard.js', { stdio: 'inherit' });
  });


program
  .command('doctor')
  .description('Validate Cerber setup (checks for missing files)')
  .action(async () => {
    const { runDoctor, printDoctorReport } = await import('../dist/cli/doctor.js');
    const result = await runDoctor(process.cwd());
    printDoctorReport(result);
    process.exit(result.exitCode);
  });

// Hidden test command: long-running process for signal testing
program
  .command('_signals-test')
  .description('[TEST ONLY] Signal handling test - requires CERBER_TEST_MODE=1')
  .action(async () => {
    // Only available in test mode
    if (process.env.CERBER_TEST_MODE !== '1') {
      console.error(chalk.red('❌ This command is disabled (test mode only)'));
      process.exit(1);
    }

    // Print ready signal
    console.log('READY');

    // Setup signal handlers
    const cleanup = async () => {
      console.log('SIGINT_RECEIVED');
      
      // Simulate cleanup work (close connections, flush logs, etc)
      await new Promise(resolve => setTimeout(resolve, 100));
      
      console.log('CLEANUP_DONE');
      process.exit(0);
    };

    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);

    // Long-running loop (60 seconds or until interrupted)
    let running = true;
    const startTime = Date.now();
    
    const interval = setInterval(() => {
      if (!running || Date.now() - startTime > 60000) {
        clearInterval(interval);
        running = false;
        process.exit(0);
      }
    }, 1000);

    // Prevent immediate exit
    await new Promise(() => {
      // Never resolves - intentional, waiting for signal
    });
  });

program.parse();

program.parse();
