/**
 * Template generator for Cerber init
 * 
 * Generates files based on CERBER_CONTRACT and mode
 * 
 * @author Stefan Pitek
 * @license MIT
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { CerberContract, GeneratedFile, InitOptions } from './types.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class TemplateGenerator {
  private projectRoot: string;
  private contract: CerberContract;
  private options: InitOptions;
  
  constructor(projectRoot: string, contract: CerberContract, options: InitOptions = {}) {
    this.projectRoot = projectRoot;
    this.contract = contract;
    this.options = options;
  }
  
  async generateAll(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // Guardian files
    if (this.contract.guardian.enabled && !this.options.noHusky) {
      files.push(...await this.generateGuardianFiles());
    }
    
    // Health files
    if (this.contract.health.enabled && !this.options.noHealth) {
      files.push(...await this.generateHealthFiles());
    }
    
    // CI workflow
    if (this.contract.ci.provider === 'github' && !this.options.noWorkflow) {
      files.push(...await this.generateCIFiles());
    }
    
    // Team mode extras
    if (this.contract.mode === 'team') {
      files.push(...await this.generateTeamFiles());
    }
    
    return files;
  }
  
  private async generateGuardianFiles(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // scripts/cerber-guardian.mjs
    const guardianScript = this.getGuardianScript();
    files.push({
      path: path.join(this.projectRoot, 'scripts', 'cerber-guardian.mjs'),
      content: guardianScript,
      generated: true
    });
    
    // .husky/pre-commit
    if (this.contract.guardian.hook === 'husky') {
      const preCommitHook = this.getPreCommitHook();
      files.push({
        path: path.join(this.projectRoot, '.husky', 'pre-commit'),
        content: preCommitHook,
        generated: true
      });
    }
    
    return files;
  }
  
  private async generateHealthFiles(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // src/cerber/health-checks.ts
    const healthChecks = this.getHealthChecksTemplate();
    files.push({
      path: path.join(this.projectRoot, 'src', 'cerber', 'health-checks.ts'),
      content: healthChecks,
      generated: true
    });
    
    // src/cerber/health-route.ts
    const healthRoute = this.getHealthRouteTemplate();
    files.push({
      path: path.join(this.projectRoot, 'src', 'cerber', 'health-route.ts'),
      content: healthRoute,
      generated: true
    });
    
    return files;
  }
  
  private async generateCIFiles(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // .github/workflows/cerber.yml
    const workflow = this.getGitHubWorkflow();
    files.push({
      path: path.join(this.projectRoot, '.github', 'workflows', 'cerber.yml'),
      content: workflow,
      generated: true
    });
    
    return files;
  }
  
  private async generateTeamFiles(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // .github/CODEOWNERS
    const codeowners = this.getCodeownersTemplate();
    files.push({
      path: path.join(this.projectRoot, '.github', 'CODEOWNERS'),
      content: codeowners,
      generated: true
    });
    
    return files;
  }
  
  private getGuardianScript(): string {
    return `#!/usr/bin/env node
// Generated by Cerber init - DO NOT EDIT MANUALLY
// To regenerate: npx cerber init --force

/**
 * Guardian Pre-commit Validator
 * 
 * Validates staged files against BACKEND_SCHEMA
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

const SCHEMA_FILE = '${this.contract.guardian.schemaFile}';
const APPROVALS_TAG = '${this.contract.guardian.approvalsTag}';

async function main() {
  console.log('üõ°Ô∏è  Cerber Guardian: Validating staged files...');
  
  // Check if schema file exists
  if (!fs.existsSync(SCHEMA_FILE)) {
    console.error(\`‚ùå Schema file not found: \${SCHEMA_FILE}\`);
    console.error('Create your schema file or run: npx cerber init');
    process.exit(1);
  }
  
  // Get staged files
  let stagedFiles;
  try {
    stagedFiles = execSync('git diff --cached --name-only', { encoding: 'utf-8' })
      .trim()
      .split('\\n')
      .filter(Boolean);
  } catch (err) {
    console.error('‚ùå Failed to get staged files');
    process.exit(1);
  }
  
  if (stagedFiles.length === 0) {
    console.log('‚úÖ No files staged for commit');
    return;
  }
  
  console.log(\`Checking \${stagedFiles.length} file(s)...\`);
  
  // TODO: Implement full validation logic in v1.1.0
  // For now, just check if schema exists
  
  console.log('‚úÖ All checks passed');
  console.log(\`Guardian validated \${stagedFiles.length} file(s)\`);
}

main().catch(err => {
  console.error('‚ùå Guardian check failed:', err.message);
  process.exit(1);
});
`;
  }
  
  private getPreCommitHook(): string {
    return `#!/bin/sh
# Generated by Cerber init

npm run cerber:guardian
`;
  }
  
  private getHealthChecksTemplate(): string {
    return `// Generated by Cerber init - CUSTOMIZE THIS FILE
// To regenerate template: npx cerber init --force

/**
 * Cerber Health Checks
 * 
 * Define your component health checks here
 */

import { CerberCheck, makeIssue } from 'cerber-core';

export const checks: Record<string, CerberCheck> = {
  database: async () => {
    // TODO: Implement your database health check
    // Example:
    // try {
    //   await db.query('SELECT 1');
    //   return [];
    // } catch (err) {
    //   return [
    //     makeIssue({
    //       code: 'DB_CONNECTION_FAILED',
    //       component: 'database',
    //       diagnosis: 'Cannot connect to database',
    //       rootCause: 'Database server is down or unreachable',
    //       fix: 'Check DATABASE_URL and verify DB is running',
    //       severity: 'critical',
    //       durationMs: 0
    //     })
    //   ];
    // }
    
    return []; // Placeholder - implement your check
  },
  
  // Add more checks as needed:
  // redis: async () => { ... },
  // api: async () => { ... },
  // cloudinary: async () => { ... },
};
`;
  }
  
  private getHealthRouteTemplate(): string {
    return `// Generated by Cerber init - CUSTOMIZE THIS FILE

/**
 * Cerber Health Route
 * 
 * Express route handler for health endpoint
 */

import { checks } from './health-checks.js';

export async function healthHandler(req: any, res: any) {
  const startTime = Date.now();
  
  try {
    const results = await Promise.all(
      Object.entries(checks).map(async ([name, check]) => ({
        name,
        issues: await check()
      }))
    );
    
    const allIssues = results.flatMap(r => r.issues);
    const critical = allIssues.filter(i => i.severity === 'critical').length;
    const errors = allIssues.filter(i => i.severity === 'error').length;
    const warnings = allIssues.filter(i => i.severity === 'warning').length;
    
    const status = critical > 0 ? 'unhealthy' : 
                   errors > 0 ? 'degraded' : 'healthy';
    
    const statusCode = status === 'healthy' ? 200 : 503;
    
    res.status(statusCode).json({
      status,
      timestamp: new Date().toISOString(),
      durationMs: Date.now() - startTime,
      summary: {
        totalChecks: results.length,
        failedChecks: results.filter(r => r.issues.length > 0).length,
        criticalIssues: critical,
        errorIssues: errors,
        warningIssues: warnings
      },
      components: allIssues
    });
  } catch (err: any) {
    res.status(503).json({
      status: 'error',
      message: 'Health check failed',
      error: err.message
    });
  }
}

// Usage in your server.ts:
// import { healthHandler } from './cerber/health-route.js';
// app.get('${this.contract.health.endpoint}', healthHandler);
`;
  }
  
  private getGitHubWorkflow(): string {
    const { postDeploy } = this.contract.ci;
    
    return `# Generated by Cerber init
name: Cerber CI

on:
  push:
    branches: ${JSON.stringify(this.contract.ci.branches)}
  pull_request:
    branches: ${JSON.stringify(this.contract.ci.branches)}

jobs:
  cerber-guardian:
    name: Guardian Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run Guardian
        run: npm run cerber:guardian
      
      - name: Run tests (if available)
        run: npm test
        continue-on-error: true
${postDeploy.enabled ? `
  post-deploy-health:
    name: Post-Deploy Health Check
    needs: [deploy]  # Add your deploy job name here
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for deployment
        run: sleep ${postDeploy.waitSeconds}
      
      - name: Check production health
        run: |
          RESPONSE=$(curl -s \${{ vars.${postDeploy.healthUrlVar} }})
          echo "Health check response: $RESPONSE"
          
          CRITICAL=$(echo "$RESPONSE" | jq -r '.summary.criticalIssues // 0')
          ERRORS=$(echo "$RESPONSE" | jq -r '.summary.errorIssues // 0')
          
          ${this.contract.health.failOn.critical ? `
          if [[ "$CRITICAL" != "0" ]]; then
            echo "‚ùå DEPLOYMENT BLOCKED - Critical issues detected"
            exit 1
          fi` : ''}
          
          ${this.contract.health.failOn.error ? `
          if [[ "$ERRORS" != "0" ]]; then
            echo "‚ùå DEPLOYMENT BLOCKED - Errors detected"
            exit 1
          fi` : ''}
          
          echo "‚úÖ Production health check passed"
` : ''}`;
  }
  
  private getCodeownersTemplate(): string {
    return `# Generated by Cerber init
# Cerber Core Files - Require architect approval

/CERBER.md @OWNER_USERNAME
/${this.contract.guardian.schemaFile} @OWNER_USERNAME
/.github/workflows/cerber.yml @OWNER_USERNAME

# Instructions:
# 1. Replace @OWNER_USERNAME with your GitHub username
# 2. Go to Settings > Branches > Branch protection rules
# 3. Enable "Require review from Code Owners"
# 4. Set "Required approving reviews" to 1
`;
  }
  
  async writeFiles(files: GeneratedFile[]): Promise<void> {
    for (const file of files) {
      if (this.options.dryRun) {
        console.log(`[DRY RUN] Would create: ${file.path}`);
        continue;
      }
      
      // Check if file exists
      const exists = await fs.access(file.path).then(() => true).catch(() => false);
      
      if (exists && !this.options.force) {
        console.log(`‚ö†Ô∏è  Skipping (already exists): ${path.relative(this.projectRoot, file.path)}`);
        continue;
      }
      
      // Create directory if needed
      await fs.mkdir(path.dirname(file.path), { recursive: true });
      
      // Write file
      await fs.writeFile(file.path, file.content, 'utf-8');
      console.log(`‚úÖ Generated: ${path.relative(this.projectRoot, file.path)}`);
    }
  }
}
