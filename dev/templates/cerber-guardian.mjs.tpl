#!/usr/bin/env node
// Generated by Cerber init - DO NOT EDIT MANUALLY
// To regenerate: npx cerber init --force

import { execSync } from 'child_process';
import fs from 'fs';
import { join } from 'path';

const SCHEMA_FILE = '{{SCHEMA_FILE}}';
const APPROVALS_TAG = '{{APPROVALS_TAG}}';

async function main() {
  console.log('üõ°Ô∏è  Cerber Guardian: Validating staged files...');

  // Check for emergency override
  const cerberMdPath = join(process.cwd(), 'CERBER.md');
  if (fs.existsSync(cerberMdPath)) {
    const cerberContent = fs.readFileSync(cerberMdPath, 'utf-8');
    const overrideMatch = cerberContent.match(/CERBER_OVERRIDE:\s*\n\s*enabled:\s*(true|false)/);
    
    if (overrideMatch && overrideMatch[1] === 'true') {
      // Extract override details
      const reasonMatch = cerberContent.match(/reason:\s*"([^"]*)"/);
      const expiresMatch = cerberContent.match(/expires:\s*"([^"]*)"/);
      const approvedByMatch = cerberContent.match(/approvedBy:\s*"([^"]*)"/);
      
      const reason = reasonMatch ? reasonMatch[1] : '';
      const expires = expiresMatch ? expiresMatch[1] : '';
      const approvedBy = approvedByMatch ? approvedByMatch[1] : '';
      
      // Check TTL
      let isExpired = false;
      if (expires) {
        try {
          const expiryDate = new Date(expires);
          const now = new Date();
          isExpired = expiryDate <= now;
        } catch {
          isExpired = true;
        }
      }
      
      if (!isExpired && reason && expires && approvedBy) {
        // Override ACTIVE - allow commit with warning
        console.log('');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('‚ö†Ô∏è  CERBER EMERGENCY OVERRIDE ACTIVE');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('');
        console.log(`Status:      ACTIVE`);
        console.log(`Reason:      ${reason}`);
        console.log(`Expires:     ${expires}`);
        console.log(`Approved By: ${approvedBy}`);
        console.log('');
        console.log('Guardian checks: BYPASSED WITH WARNING');
        console.log('Self-protection: STILL ACTIVE (cerber-integrity runs)');
        console.log('');
        console.log('‚ö†Ô∏è  Create follow-up PR to fix properly + disable override');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('');
        process.exit(0);  // Allow commit
      } else if (isExpired) {
        console.log('‚ö†Ô∏è  Override expired - proceeding with normal validation');
      } else {
        console.log('‚ö†Ô∏è  Override invalid (missing required fields) - proceeding with normal validation');
      }
    }
  }

  if (!fs.existsSync(SCHEMA_FILE)) {
    console.error(`‚ùå Schema file not found: ${SCHEMA_FILE}`);
    console.error('Create your schema file to enable validation.');
    console.error(`Example: npx cerber init --print-schema-template > ${SCHEMA_FILE}`);
    process.exit(1);
  }

  // Import schema
  let schema;
  try {
    const schemaPath = join(process.cwd(), SCHEMA_FILE);
    const schemaModule = await import(`file://${schemaPath}`);
    schema = schemaModule.BACKEND_SCHEMA || schemaModule.default || schemaModule;
  } catch (err) {
    console.error(`‚ùå Failed to load schema from ${SCHEMA_FILE}:`, err.message);
    process.exit(1);
  }

  // Get staged files
  let stagedFiles;
  try {
    stagedFiles = execSync('git diff --cached --name-only', { encoding: 'utf-8' })
      .trim()
      .split('\n')
      .filter(Boolean);
  } catch (err) {
    console.error('‚ùå Failed to get staged files');
    process.exit(1);
  }

  if (stagedFiles.length === 0) {
    console.log('‚úÖ No files staged for commit');
    return;
  }

  console.log(`Checking ${stagedFiles.length} file(s)...`);

  const violations = [];

  // Validate each staged file
  for (const file of stagedFiles) {
    if (!fs.existsSync(file)) continue;

    const content = fs.readFileSync(file, 'utf-8');

    // Check forbidden patterns
    if (schema.forbiddenPatterns && Array.isArray(schema.forbiddenPatterns)) {
      for (const rule of schema.forbiddenPatterns) {
        if (!rule.pattern) continue;

        const pattern = typeof rule.pattern === 'string' 
          ? new RegExp(rule.pattern, rule.flags || 'i') 
          : rule.pattern;
        
        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        if (pattern.test(content)) {
          // Check for architect approval
          const hasApproval = content.includes(APPROVALS_TAG);
          
          if (!hasApproval) {
            violations.push({
              file,
              rule: rule.name || 'Unnamed rule',
              severity: rule.severity || 'error'
            });
          }
        }
      }
    }

    // Check required imports (rules)
    if (schema.rules && Array.isArray(schema.rules)) {
      for (const rule of schema.rules) {
        if (!rule.pattern || !rule.requiredImports) continue;

        const filePattern = typeof rule.pattern === 'string' ? new RegExp(rule.pattern) : rule.pattern;
        
        if (!filePattern.test(file)) continue;

        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        // Check each required import
        for (const requiredImport of rule.requiredImports) {
          const importPattern = new RegExp(`import.*${requiredImport}`, 'i');
          
          if (!importPattern.test(content)) {
            // Check for architect approval
            const hasApproval = content.includes(APPROVALS_TAG);
            
            if (!hasApproval) {
              violations.push({
                file,
                rule: `${rule.name || 'Unnamed rule'}: missing import '${requiredImport}'`,
                severity: rule.severity || 'error'
              });
            }
          }
        }
      }
    }
  }

  // Report violations
  if (violations.length > 0) {
    console.error('\n‚ùå Architecture violations detected:\n');
    
    for (const v of violations) {
      const icon = v.severity === 'error' ? 'üî¥' : '‚ö†Ô∏è';
      console.error(`${icon} [${v.severity.toUpperCase()}] ${v.file}`);
      console.error(`   ${v.rule}`);
      console.error(`   Add ${APPROVALS_TAG} comment to override\n`);
    }
    
    const errorCount = violations.filter(v => v.severity === 'error').length;
    if (errorCount > 0) {
      console.error(`\n‚ùå Commit blocked: ${errorCount} error(s) found`);
      process.exit(1);
    }
  }

  console.log('‚úÖ All checks passed');
}

main().catch(err => {
  console.error('‚ùå Guardian check failed:', err?.message || err);
  process.exit(1);
});
