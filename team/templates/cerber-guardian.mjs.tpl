#!/usr/bin/env node
// Generated by Cerber init - DO NOT EDIT MANUALLY
// To regenerate: npx cerber init --force

import { execSync } from 'child_process';
import fs from 'fs';
import { join } from 'path';

const APPROVALS_TAG = '{{APPROVALS_TAG}}';

function readYamlValue(text, key) {
  const re = new RegExp(`^\\s*${key}\\s*:\\s*(.*)\\s*$`, "m");
  const m = text.match(re);
  if (!m) return "";
  let v = (m[1] ?? "").trim();
  // Remove quotes
  v = v.replace(/^["']/, "").replace(/["']$/, "");
  return v;
}

function parseOverride(cerberContent) {
  const enabledRaw = readYamlValue(cerberContent, "enabled");
  const enabled = enabledRaw.toLowerCase() === "true";

  const reason = readYamlValue(cerberContent, "reason");
  const expiresRaw = readYamlValue(cerberContent, "expires");
  const approvedBy = readYamlValue(cerberContent, "approvedBy");

  if (!enabled) return { state: "DISABLED", reason, expires: expiresRaw, approvedBy };

  if (!expiresRaw) return { state: "ACTIVE", reason, expires: "", approvedBy };

  const expiresDate = new Date(expiresRaw);
  if (Number.isNaN(expiresDate.getTime())) {
    return { state: "INVALID", reason, expires: expiresRaw, approvedBy };
  }

  if (expiresDate.getTime() < Date.now()) {
    return { state: "EXPIRED", reason, expires: expiresRaw, approvedBy };
  }

  return { state: "ACTIVE", reason, expires: expiresRaw, approvedBy };
}

async function main() {
  console.log('üõ°Ô∏è  Cerber Guardian: Validating staged files...');

  // Check for emergency override
  const cerberMdPath = join(process.cwd(), 'CERBER.md');
  if (fs.existsSync(cerberMdPath)) {
    const cerberContent = fs.readFileSync(cerberMdPath, 'utf-8');
    const overrideMatch = cerberContent.match(/CERBER_OVERRIDE:\s*\n\s*enabled:\s*(true|false)/);
    
    if (overrideMatch && overrideMatch[1] === 'true') {
      const override = parseOverride(cerberContent);
      const { state, reason, expires, approvedBy } = override;
      
      if (state === 'ACTIVE') {
        // Override ACTIVE - allow commit with warning
        console.log('');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('‚ö†Ô∏è  CERBER EMERGENCY OVERRIDE ACTIVE');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('');
        console.log(`Status:      ACTIVE`);
        console.log(`Reason:      ${reason}`);
        console.log(`Expires:     ${expires}`);
        console.log(`Approved By: ${approvedBy}`);
        console.log('');
        console.log('Guardian checks: BYPASSED WITH WARNING');
        console.log('Self-protection: STILL ACTIVE (cerber-integrity runs)');
        console.log('');
        console.log('‚ö†Ô∏è  Create follow-up PR to fix properly + disable override');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('');
        process.exit(0);  // Allow commit
      } else if (state === 'EXPIRED') {
        console.log('‚ö†Ô∏è  Override expired - proceeding with normal validation');
      } else {
        console.log('‚ö†Ô∏è  Override invalid (missing required fields) - proceeding with normal validation');
      }
    }
  }

  // Load schema from CERBER.md
  if (!fs.existsSync(cerberMdPath)) {
    console.error('‚ùå CERBER.md not found');
    console.error('Run: npx cerber init');
    process.exit(5);
  }

  const cerberContent = fs.readFileSync(cerberMdPath, 'utf-8');
  
  // Parse SCHEMA section
  const schemaMatch = cerberContent.match(/SCHEMA:\s*\n\s*mode:\s*(\w+)/);
  if (!schemaMatch) {
    console.error('‚ùå SCHEMA section not found in CERBER.md');
    console.error('Add SCHEMA section with mode: required or mode: disabled');
    process.exit(5);
  }

  const schemaMode = schemaMatch[1];
  if (schemaMode === 'disabled') {
    console.log('‚ö†Ô∏è  Schema validation disabled (SCHEMA.mode: disabled)');
    console.log('‚úÖ Bypassing validation');
    return;
  }

  // Extract forbidden patterns
  const forbiddenPatterns = [];
  const patternsMatch = cerberContent.match(/forbiddenPatterns:\s*\n([\s\S]*?)(?=\n\w|\nSCHEMA:|$)/);
  if (patternsMatch) {
    const patternLines = patternsMatch[1].match(/- "([^"]+)"/g);
    if (patternLines) {
      patternLines.forEach(line => {
        const pattern = line.match(/- "([^"]+)"/)?.[1];
        if (pattern) {
          forbiddenPatterns.push({
            pattern: pattern,
            name: `Forbidden: ${pattern}`,
            severity: 'error'
          });
        }
      });
    }
  }

  if (schemaMode === 'required' && forbiddenPatterns.length === 0) {
    console.error('‚ùå SCHEMA.mode: required but no rules defined');
    console.error('Add forbiddenPatterns to SCHEMA section in CERBER.md');
    process.exit(5);
  }

  const schema = {
    forbiddenPatterns: forbiddenPatterns,
    rules: []
  };

  // Get staged files
  let stagedFiles;
  try {
    stagedFiles = execSync('git diff --cached --name-only', { encoding: 'utf-8' })
      .trim()
      .split('\n')
      .filter(Boolean);
  } catch (err) {
    console.error('‚ùå Failed to get staged files');
    process.exit(1);
  }

  if (stagedFiles.length === 0) {
    console.log('‚úÖ No files staged for commit');
    return;
  }

  console.log(`Checking ${stagedFiles.length} file(s)...`);

  const violations = [];

  // Validate each staged file
  for (const file of stagedFiles) {
    if (!fs.existsSync(file)) continue;

    const content = fs.readFileSync(file, 'utf-8');

    // Check forbidden patterns
    if (schema.forbiddenPatterns && Array.isArray(schema.forbiddenPatterns)) {
      for (const rule of schema.forbiddenPatterns) {
        if (!rule.pattern) continue;

        const pattern = typeof rule.pattern === 'string' 
          ? new RegExp(rule.pattern, rule.flags || 'i') 
          : rule.pattern;
        
        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        if (pattern.test(content)) {
          // Check for architect approval
          const hasApproval = content.includes(APPROVALS_TAG);
          
          if (!hasApproval) {
            violations.push({
              file,
              rule: rule.name || 'Unnamed rule',
              severity: rule.severity || 'error'
            });
          }
        }
      }
    }

    // Check required imports (rules)
    if (schema.rules && Array.isArray(schema.rules)) {
      for (const rule of schema.rules) {
        if (!rule.pattern || !rule.requiredImports) continue;

        const filePattern = typeof rule.pattern === 'string' ? new RegExp(rule.pattern) : rule.pattern;
        
        if (!filePattern.test(file)) continue;

        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        // Check each required import
        for (const requiredImport of rule.requiredImports) {
          const importPattern = new RegExp(`import.*${requiredImport}`, 'i');
          
          if (!importPattern.test(content)) {
            // Check for architect approval
            const hasApproval = content.includes(APPROVALS_TAG);
            
            if (!hasApproval) {
              violations.push({
                file,
                rule: `${rule.name || 'Unnamed rule'}: missing import '${requiredImport}'`,
                severity: rule.severity || 'error'
              });
            }
          }
        }
      }
    }
  }

  // Report violations
  if (violations.length > 0) {
    console.error('\n‚ùå Architecture violations detected:\n');
    
    for (const v of violations) {
      const icon = v.severity === 'error' ? 'üî¥' : '‚ö†Ô∏è';
      console.error(`${icon} [${v.severity.toUpperCase()}] ${v.file}`);
      console.error(`   ${v.rule}`);
      console.error(`   Add ${APPROVALS_TAG} comment to override\n`);
    }
    
    const errorCount = violations.filter(v => v.severity === 'error').length;
    if (errorCount > 0) {
      console.error(`\n‚ùå Commit blocked: ${errorCount} error(s) found`);
      process.exit(1);
    }
  }

  console.log('‚úÖ All checks passed');
}

main().catch(err => {
  console.error('‚ùå Guardian check failed:', err?.message || err);
  process.exit(1);
});
